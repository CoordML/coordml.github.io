{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CoordML CoordML is an easy-to-use tool for automating ML experimenting. It supports defining computation tasks with a powerful and flexible DSL, Sircle. Tasks will be distributed to multiple computing instances whenever possible, and a web portal can be used to view current state of experiments and display aggregated experiment results in a clean and flexible way.","title":"Home"},{"location":"#coordml","text":"CoordML is an easy-to-use tool for automating ML experimenting. It supports defining computation tasks with a powerful and flexible DSL, Sircle. Tasks will be distributed to multiple computing instances whenever possible, and a web portal can be used to view current state of experiments and display aggregated experiment results in a clean and flexible way.","title":"CoordML"},{"location":"central_api/experiments/","text":"Experiment Management API Experiment management API is located in the path {SERVER_URL}/api/exp . Creating Experiments Create an experiment. Experiment configuration should be given, and the id of the created experiment will be return. The experiment will be run immediately after being created. URL /api/exp/create Method POST Parameters 1 2 3 4 5 6 7 8 9 10 11 12 { \"title\" : String , \"author\" : String , \"config\" : Object , \"resolverPath\" : String , \"envPath\" : String , \"resultParse\" : String , \"resultView\" : { \"rowKey\" : [ String ], \"columnKey\" : [ String ], } } Return Value 1 2 3 { \"expId\" : String } Getting Overview of Experiments Get the overview of the specified experiment. The experiment should be specified through GET parameters. URL /api/exp/getOverview?expId={exp_id} Method GET Parameters exp_id is specified in the URL. Return Value 1 2 3 4 5 6 { \"expId\" : String , \"title\" : String , \"envPath\" : String , \"progress\" : Double } Listing Overview of Experiments List the overview of all experiments. URL /api/exp/listOverview Method GET Parameters None Return Value 1 2 3 4 5 6 7 8 [ { \"expId\" : String , \"title\" : String , \"envPath\" : String , \"progress\" : Double } ] Listing Experiment Results List results of the given experiment. The returned results are given in the form of a table. URL /api/exp/listResults?expId={exp_id} Method GET Parameters Given in the URL. Return Value 1 2 3 4 { \"columns\" : [ String ], \"results\" : [[ String ]] } Getting Result View Get the result view of the given experiment. The view is also returned in the form of a table. URL /api/exp/getResultView?expId={exp_id} Method GET Parameters Given in the URL. Return Value 1 2 3 4 { \"columns\" : [ String ], \"results\" : [[ String ]] } Listing Rendered Tasks List rendered tasks. Task arguments and tags are returned in rendered HTML. URL /api/exp/listRenderedTasks?expId={exp_id} Method GET Parameters Given in the URL. Return Value 1 2 3 4 5 6 7 8 9 { \"tasks\" : [{ \"taskId\" : String , \"executable\" : String , \"status\" : String , \"args\" : String , \"tags\" : String }] }","title":"Experiment Management API"},{"location":"central_api/experiments/#experiment-management-api","text":"Experiment management API is located in the path {SERVER_URL}/api/exp .","title":"Experiment Management API"},{"location":"central_api/experiments/#creating-experiments","text":"Create an experiment. Experiment configuration should be given, and the id of the created experiment will be return. The experiment will be run immediately after being created.","title":"Creating Experiments"},{"location":"central_api/experiments/#url","text":"/api/exp/create","title":"URL"},{"location":"central_api/experiments/#method","text":"POST","title":"Method"},{"location":"central_api/experiments/#parameters","text":"1 2 3 4 5 6 7 8 9 10 11 12 { \"title\" : String , \"author\" : String , \"config\" : Object , \"resolverPath\" : String , \"envPath\" : String , \"resultParse\" : String , \"resultView\" : { \"rowKey\" : [ String ], \"columnKey\" : [ String ], } }","title":"Parameters"},{"location":"central_api/experiments/#return-value","text":"1 2 3 { \"expId\" : String }","title":"Return Value"},{"location":"central_api/experiments/#getting-overview-of-experiments","text":"Get the overview of the specified experiment. The experiment should be specified through GET parameters.","title":"Getting Overview of Experiments"},{"location":"central_api/experiments/#url_1","text":"/api/exp/getOverview?expId={exp_id}","title":"URL"},{"location":"central_api/experiments/#method_1","text":"GET","title":"Method"},{"location":"central_api/experiments/#parameters_1","text":"exp_id is specified in the URL.","title":"Parameters"},{"location":"central_api/experiments/#return-value_1","text":"1 2 3 4 5 6 { \"expId\" : String , \"title\" : String , \"envPath\" : String , \"progress\" : Double }","title":"Return Value"},{"location":"central_api/experiments/#listing-overview-of-experiments","text":"List the overview of all experiments.","title":"Listing Overview of Experiments"},{"location":"central_api/experiments/#url_2","text":"/api/exp/listOverview","title":"URL"},{"location":"central_api/experiments/#method_2","text":"GET","title":"Method"},{"location":"central_api/experiments/#parameters_2","text":"None","title":"Parameters"},{"location":"central_api/experiments/#return-value_2","text":"1 2 3 4 5 6 7 8 [ { \"expId\" : String , \"title\" : String , \"envPath\" : String , \"progress\" : Double } ]","title":"Return Value"},{"location":"central_api/experiments/#listing-experiment-results","text":"List results of the given experiment. The returned results are given in the form of a table.","title":"Listing Experiment Results"},{"location":"central_api/experiments/#url_3","text":"/api/exp/listResults?expId={exp_id}","title":"URL"},{"location":"central_api/experiments/#method_3","text":"GET","title":"Method"},{"location":"central_api/experiments/#parameters_3","text":"Given in the URL.","title":"Parameters"},{"location":"central_api/experiments/#return-value_3","text":"1 2 3 4 { \"columns\" : [ String ], \"results\" : [[ String ]] }","title":"Return Value"},{"location":"central_api/experiments/#getting-result-view","text":"Get the result view of the given experiment. The view is also returned in the form of a table.","title":"Getting Result View"},{"location":"central_api/experiments/#url_4","text":"/api/exp/getResultView?expId={exp_id}","title":"URL"},{"location":"central_api/experiments/#method_4","text":"GET","title":"Method"},{"location":"central_api/experiments/#parameters_4","text":"Given in the URL.","title":"Parameters"},{"location":"central_api/experiments/#return-value_4","text":"1 2 3 4 { \"columns\" : [ String ], \"results\" : [[ String ]] }","title":"Return Value"},{"location":"central_api/experiments/#listing-rendered-tasks","text":"List rendered tasks. Task arguments and tags are returned in rendered HTML.","title":"Listing Rendered Tasks"},{"location":"central_api/experiments/#url_5","text":"/api/exp/listRenderedTasks?expId={exp_id}","title":"URL"},{"location":"central_api/experiments/#method_5","text":"GET","title":"Method"},{"location":"central_api/experiments/#parameters_5","text":"Given in the URL.","title":"Parameters"},{"location":"central_api/experiments/#return-value_5","text":"1 2 3 4 5 6 7 8 9 { \"tasks\" : [{ \"taskId\" : String , \"executable\" : String , \"status\" : String , \"args\" : String , \"tags\" : String }] }","title":"Return Value"},{"location":"central_api/overview/","text":"CoordML Central Server API Overview The API of CoordML Central mainly consists of two parts: Worker Management. Related API for the registeration, status reporting, task dispatching and results reporting of runner instances. Experiment Management. Related API for the creation and listing of experiments. Generally, CoordML runners will firstly register itself to the central, then fetch and run the computational tasks, and finally extract and report the results to the central. The CoordML CLI is a client of the experiment management APIs, providing a easy-to-use interface for creating experiments from configuration files. All API interfaces reside at the path {SERVER_URL}/api and have different postfixes. Here, {SERVER_URL} refer to the root serving endpoing of the CoordML Central.","title":"Overview"},{"location":"central_api/overview/#coordml-central-server-api-overview","text":"The API of CoordML Central mainly consists of two parts: Worker Management. Related API for the registeration, status reporting, task dispatching and results reporting of runner instances. Experiment Management. Related API for the creation and listing of experiments. Generally, CoordML runners will firstly register itself to the central, then fetch and run the computational tasks, and finally extract and report the results to the central. The CoordML CLI is a client of the experiment management APIs, providing a easy-to-use interface for creating experiments from configuration files. All API interfaces reside at the path {SERVER_URL}/api and have different postfixes. Here, {SERVER_URL} refer to the root serving endpoing of the CoordML Central.","title":"CoordML Central Server API Overview"},{"location":"central_api/workers/","text":"Worker Management API Worker management APIs are located at /api/workers . Registering Register runner to a given name. Return the runner id. URL /api/workers/register Method POST Parameters 1 2 3 { \"name\" : String } Return Value 1 2 3 { \"workerId\" : String } Listing Workers List currently registered workers. URL /api/workers/list Method GET Parameters None. Return Value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"workers\" : [{ \"workerId\" : String , \"name\" : String , \"gpuStatus\" : [{ \"name\" : String , \"memUsage\" : { \"used\" : Double , \"capacity\" : Double } }], \"pendingTasks\" : [ RunnableGraph ] }] } Reporting Worker GPU Usage Report current GPU usage statistics. URL /api/workers/reportGpu Method POST Parameters 1 2 3 4 5 6 7 8 9 10 11 { \"workerId\" : String , \"name\" : String , \"gpuStatus\" : [{ \"name\" : String , \"memUsage\" : { \"used\" : Double , \"capacity\" : Double } }] } Return Value If the GPU status is updated successfully, the reported GPU statistics will be returned. Fetching Worker Tasks Fetch the pending tasks of the given worker. URL /api/workers/fetchTasks?workerId={worker_id} Method GET Parameters Given in the URL. Return Value 1 2 3 { \"tasks\" : [ RunnableGraph ] } Reporting Task Results Report task results. URL /api/workers/reportResult?workerId={worker_id} Method POST Parameters 1 2 3 4 5 6 { \"expId\" : String , \"graphId\" : String , \"taskId\" : String , \"results\" : Object } Return Value None.","title":"Worker Management API"},{"location":"central_api/workers/#worker-management-api","text":"Worker management APIs are located at /api/workers .","title":"Worker Management API"},{"location":"central_api/workers/#registering","text":"Register runner to a given name. Return the runner id.","title":"Registering"},{"location":"central_api/workers/#url","text":"/api/workers/register","title":"URL"},{"location":"central_api/workers/#method","text":"POST","title":"Method"},{"location":"central_api/workers/#parameters","text":"1 2 3 { \"name\" : String }","title":"Parameters"},{"location":"central_api/workers/#return-value","text":"1 2 3 { \"workerId\" : String }","title":"Return Value"},{"location":"central_api/workers/#listing-workers","text":"List currently registered workers.","title":"Listing Workers"},{"location":"central_api/workers/#url_1","text":"/api/workers/list","title":"URL"},{"location":"central_api/workers/#method_1","text":"GET","title":"Method"},{"location":"central_api/workers/#parameters_1","text":"None.","title":"Parameters"},{"location":"central_api/workers/#return-value_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"workers\" : [{ \"workerId\" : String , \"name\" : String , \"gpuStatus\" : [{ \"name\" : String , \"memUsage\" : { \"used\" : Double , \"capacity\" : Double } }], \"pendingTasks\" : [ RunnableGraph ] }] }","title":"Return Value"},{"location":"central_api/workers/#reporting-worker-gpu-usage","text":"Report current GPU usage statistics.","title":"Reporting Worker GPU Usage"},{"location":"central_api/workers/#url_2","text":"/api/workers/reportGpu","title":"URL"},{"location":"central_api/workers/#method_2","text":"POST","title":"Method"},{"location":"central_api/workers/#parameters_2","text":"1 2 3 4 5 6 7 8 9 10 11 { \"workerId\" : String , \"name\" : String , \"gpuStatus\" : [{ \"name\" : String , \"memUsage\" : { \"used\" : Double , \"capacity\" : Double } }] }","title":"Parameters"},{"location":"central_api/workers/#return-value_2","text":"If the GPU status is updated successfully, the reported GPU statistics will be returned.","title":"Return Value"},{"location":"central_api/workers/#fetching-worker-tasks","text":"Fetch the pending tasks of the given worker.","title":"Fetching Worker Tasks"},{"location":"central_api/workers/#url_3","text":"/api/workers/fetchTasks?workerId={worker_id}","title":"URL"},{"location":"central_api/workers/#method_3","text":"GET","title":"Method"},{"location":"central_api/workers/#parameters_3","text":"Given in the URL.","title":"Parameters"},{"location":"central_api/workers/#return-value_3","text":"1 2 3 { \"tasks\" : [ RunnableGraph ] }","title":"Return Value"},{"location":"central_api/workers/#reporting-task-results","text":"Report task results.","title":"Reporting Task Results"},{"location":"central_api/workers/#url_4","text":"/api/workers/reportResult?workerId={worker_id}","title":"URL"},{"location":"central_api/workers/#method_4","text":"POST","title":"Method"},{"location":"central_api/workers/#parameters_4","text":"1 2 3 4 5 6 { \"expId\" : String , \"graphId\" : String , \"taskId\" : String , \"results\" : Object }","title":"Parameters"},{"location":"central_api/workers/#return-value_4","text":"None.","title":"Return Value"},{"location":"cli/basic_usage/","text":"Basic Usage Creating Experiments To create a experiment with given configuration file, run 1 cm create config.yaml This will create a experiment using Central server API /api/exp/create based on config.yaml . The API endpoint can be specified with parameter --api_entry URL . Configuration Format An example configuration file is given as follows. 1 2 3 4 5 6 7 8 9 10 11 12 title : A Simple Experiment # title of the experiment author : Linyxus # author config : # config value that will be passed to the resolver seed : [ 312 , 3213 , 43214 , 321321 , 321312 , 321321 ] x : [ 1.0 , 2.0 , 3.0 ] y : [ 3.0 , 4.0 , 5.0 ] resolver_path : test.sircle # Sircle source file containing the resolver env_path : ~/tmp/test # experiment environment path result_parse : \"z {z:f}\" # parse rule to parse results result_view : # result view definition for displaying results row_key : [] column_key : [ \"x\" , \"y\" ] Caution Always run CoordML CLI on the same server as the Central. Since the various paths in the config will be expanded before being submitted to the Central, the path tends to be wrong if the client and the server are on different hosts. Getting Help Get help of cm , run 1 cm --help","title":"Basic Usage"},{"location":"cli/basic_usage/#basic-usage","text":"","title":"Basic Usage"},{"location":"cli/basic_usage/#creating-experiments","text":"To create a experiment with given configuration file, run 1 cm create config.yaml This will create a experiment using Central server API /api/exp/create based on config.yaml . The API endpoint can be specified with parameter --api_entry URL .","title":"Creating Experiments"},{"location":"cli/basic_usage/#configuration-format","text":"An example configuration file is given as follows. 1 2 3 4 5 6 7 8 9 10 11 12 title : A Simple Experiment # title of the experiment author : Linyxus # author config : # config value that will be passed to the resolver seed : [ 312 , 3213 , 43214 , 321321 , 321312 , 321321 ] x : [ 1.0 , 2.0 , 3.0 ] y : [ 3.0 , 4.0 , 5.0 ] resolver_path : test.sircle # Sircle source file containing the resolver env_path : ~/tmp/test # experiment environment path result_parse : \"z {z:f}\" # parse rule to parse results result_view : # result view definition for displaying results row_key : [] column_key : [ \"x\" , \"y\" ] Caution Always run CoordML CLI on the same server as the Central. Since the various paths in the config will be expanded before being submitted to the Central, the path tends to be wrong if the client and the server are on different hosts.","title":"Configuration Format"},{"location":"cli/basic_usage/#getting-help","text":"Get help of cm , run 1 cm --help","title":"Getting Help"},{"location":"cli/installation/","text":"Installation CoordML CLI is a client for CoordML Central written in Python. Via PyPi It is possible to install it on PyPi. Lastest version can be found at coordml-cli . To install, run 1 pip install coordml-cli To install it directly from Github repo, run 1 pip install git+https://github.com/coordml/cli.git To verify the installation, run 1 cm --help","title":"Installation"},{"location":"cli/installation/#installation","text":"CoordML CLI is a client for CoordML Central written in Python.","title":"Installation"},{"location":"cli/installation/#via-pypi","text":"It is possible to install it on PyPi. Lastest version can be found at coordml-cli . To install, run 1 pip install coordml-cli To install it directly from Github repo, run 1 pip install git+https://github.com/coordml/cli.git To verify the installation, run 1 cm --help","title":"Via PyPi"},{"location":"quick_start/central_setup/","text":"CoordML Central Setup","title":"CoordML Central Setup"},{"location":"quick_start/central_setup/#coordml-central-setup","text":"","title":"CoordML Central Setup"},{"location":"quick_start/overview/","text":"Overview Central Server Setup Central Runner Setup","title":"Overview"},{"location":"quick_start/overview/#overview","text":"Central Server Setup Central Runner Setup","title":"Overview"},{"location":"quick_start/runner_setup/","text":"CoordML Runner Setup","title":"CoordML Runner Setup"},{"location":"quick_start/runner_setup/#coordml-runner-setup","text":"","title":"CoordML Runner Setup"},{"location":"runner_api/overview/","text":"CoordML Runner Overview CoordML system is currently shipped with a Python runner ( runner ). However, CoordML do not place more restriction on runners than some API specifications. In other words, it is possible to extend the CoordML system by implementing runners in other languages, such as Java and C++, to run tasks in various types.","title":"Overview"},{"location":"runner_api/overview/#coordml-runner-overview","text":"CoordML system is currently shipped with a Python runner ( runner ). However, CoordML do not place more restriction on runners than some API specifications. In other words, it is possible to extend the CoordML system by implementing runners in other languages, such as Java and C++, to run tasks in various types.","title":"CoordML Runner Overview"},{"location":"runner_api/python_runner_usage/","text":"Python Runner Usage To launch the runner, run 1 cm_runner --config runner.yaml Here, runner.yaml is the runner configuration. Here is an exmample of the configuration. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 name : \"Runner\" # Runner name api_endpoint : http://127.0.0.1:8888/api # API endpoint runner : # GPU usage policy max_tasks_per_gpu : 1 max_gpu_load : 1.0 min_gpu_mem : 0.0 log_path : ~/.coordml # Path to task log gpu_mode : fake : true # Generate fake GPU statistics if set to true gpu_num : 4 # fake GPU number gpu_name : Titan Xp # fake GPU name gpu_mem : 31300 # fake GPU memory","title":"Python Runner Usage"},{"location":"runner_api/python_runner_usage/#python-runner-usage","text":"To launch the runner, run 1 cm_runner --config runner.yaml Here, runner.yaml is the runner configuration. Here is an exmample of the configuration. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 name : \"Runner\" # Runner name api_endpoint : http://127.0.0.1:8888/api # API endpoint runner : # GPU usage policy max_tasks_per_gpu : 1 max_gpu_load : 1.0 min_gpu_mem : 0.0 log_path : ~/.coordml # Path to task log gpu_mode : fake : true # Generate fake GPU statistics if set to true gpu_num : 4 # fake GPU number gpu_name : Titan Xp # fake GPU name gpu_mem : 31300 # fake GPU memory","title":"Python Runner Usage"},{"location":"runner_api/spec/","text":"Runner API Specification A CoordML runner should implement the following APIs: Registering. Register self to the Central and obtain an id. From then on, communicate with the server with the id. GPU Statstics Reporting. (optional) Report the current GPU usage to the server. Task Fetching. Periodically fetch assigned tasks from the server. Results Reporting. After finishing the task, report the extracted results to the server. Details of the API interfaces can be found in Worker Management API . Registering A runner have to obtain a worker id by registering itself to the Central Server. A unique name should be given when registering. A name will be associated with only one worker id at any time. If reregister a existing name, all information of the former worker instance will be migrated and a new worker id will be generated. GPU Statistics Reporting A runner should periodically report its GPU statistics to the Central. The reported information will be displayed on the Portal. Task Fetching A runner should periodically ask the central for tasks to be run. Once fetched, the task information will be deleted on the server side. Therefore the runner is responsible for storing the pending tasks. Result Reporting Once the runner finished a task, it should extract task results according to the parse rules, and report the results to the Central server.","title":"Runner Specification"},{"location":"runner_api/spec/#runner-api-specification","text":"A CoordML runner should implement the following APIs: Registering. Register self to the Central and obtain an id. From then on, communicate with the server with the id. GPU Statstics Reporting. (optional) Report the current GPU usage to the server. Task Fetching. Periodically fetch assigned tasks from the server. Results Reporting. After finishing the task, report the extracted results to the server. Details of the API interfaces can be found in Worker Management API .","title":"Runner API Specification"},{"location":"runner_api/spec/#registering","text":"A runner have to obtain a worker id by registering itself to the Central Server. A unique name should be given when registering. A name will be associated with only one worker id at any time. If reregister a existing name, all information of the former worker instance will be migrated and a new worker id will be generated.","title":"Registering"},{"location":"runner_api/spec/#gpu-statistics-reporting","text":"A runner should periodically report its GPU statistics to the Central. The reported information will be displayed on the Portal.","title":"GPU Statistics Reporting"},{"location":"runner_api/spec/#task-fetching","text":"A runner should periodically ask the central for tasks to be run. Once fetched, the task information will be deleted on the server side. Therefore the runner is responsible for storing the pending tasks.","title":"Task Fetching"},{"location":"runner_api/spec/#result-reporting","text":"Once the runner finished a task, it should extract task results according to the parse rules, and report the results to the Central server.","title":"Result Reporting"},{"location":"sircle_dsl/basics/","text":"Basics Structure of Sircle Source A Sircle source file consists a sequence of global bindings. For example: Example 1 2 3 4 5 6 7 8 9 10 11 type Foo = { \"x\": Double, \"y\": Double } def point: Foo = { \"x\" -> 1.0, \"y\" -> 2.0 } def printFoo = p: Foo => { print \"(\" print (p.\"x\") print \", \" print (p.\"y\") println \")\\n\" } The above source example binds three names in the top level: Foo , point , and printFoo . There are two types of global bindings: Type binding. Example: type Foo = { \"x\": Double, \"y\": Double } . It is similar to type aliasing in other languages. Value binding. Example: def point: Foo = ... and def printFoo = ... . It binds a value to a name in the top level. Basic Datatypes Primitive Types Type C++ Type Scala Type Haksell Type Int int Int Int Double double Double Double String std::string String Data.Text Boolean bool Boolean Boolean Unit Unit () Any Unit forall a. a Any value of Any type can be assumed a value of type Any . List Type List in Sircle is similar to list in Python, which can contain values of different types. Therefore, List type is not parameterized, and any List value has the same List type. We can construct a list in Sircle by using list lexemes. For instance, 1 def xs = [1, \"2\", False] We can access list elements using its index. 1 2 xs.1 // => \"2\" The cons built-in function can be used to prepend a value to a list. 1 2 cons 1 [2, 3] // => [1, 2, 3] Additionally, we can concat two lists simply using the + operator. 1 2 [1, 2, 3] + [\"4\", \"5\", \"6\"] // => [1, 2, 3, \"4\", \"5\", \"6\"] Some library functions are defined in Sircle Prelude to manipulate list values. 1 2 3 4 5 6 7 8 map show [1, 2, 3] // => [\"1\", \"2\", \"3\"] foldl (x => y => x * y) 1 [1, 2, 3] // => 6 zipWith (x => y => show x + show y) [1, 2, 3] [True, False, True] // => [\"1True\", \"2False\", \"3True\"] Tuple Type Mapping Type Lambda Type","title":"Basics"},{"location":"sircle_dsl/basics/#basics","text":"","title":"Basics"},{"location":"sircle_dsl/basics/#structure-of-sircle-source","text":"A Sircle source file consists a sequence of global bindings. For example: Example 1 2 3 4 5 6 7 8 9 10 11 type Foo = { \"x\": Double, \"y\": Double } def point: Foo = { \"x\" -> 1.0, \"y\" -> 2.0 } def printFoo = p: Foo => { print \"(\" print (p.\"x\") print \", \" print (p.\"y\") println \")\\n\" } The above source example binds three names in the top level: Foo , point , and printFoo . There are two types of global bindings: Type binding. Example: type Foo = { \"x\": Double, \"y\": Double } . It is similar to type aliasing in other languages. Value binding. Example: def point: Foo = ... and def printFoo = ... . It binds a value to a name in the top level.","title":"Structure of Sircle Source"},{"location":"sircle_dsl/basics/#basic-datatypes","text":"","title":"Basic Datatypes"},{"location":"sircle_dsl/basics/#primitive-types","text":"Type C++ Type Scala Type Haksell Type Int int Int Int Double double Double Double String std::string String Data.Text Boolean bool Boolean Boolean Unit Unit () Any Unit forall a. a Any value of Any type can be assumed a value of type Any .","title":"Primitive Types"},{"location":"sircle_dsl/basics/#list-type","text":"List in Sircle is similar to list in Python, which can contain values of different types. Therefore, List type is not parameterized, and any List value has the same List type. We can construct a list in Sircle by using list lexemes. For instance, 1 def xs = [1, \"2\", False] We can access list elements using its index. 1 2 xs.1 // => \"2\" The cons built-in function can be used to prepend a value to a list. 1 2 cons 1 [2, 3] // => [1, 2, 3] Additionally, we can concat two lists simply using the + operator. 1 2 [1, 2, 3] + [\"4\", \"5\", \"6\"] // => [1, 2, 3, \"4\", \"5\", \"6\"] Some library functions are defined in Sircle Prelude to manipulate list values. 1 2 3 4 5 6 7 8 map show [1, 2, 3] // => [\"1\", \"2\", \"3\"] foldl (x => y => x * y) 1 [1, 2, 3] // => 6 zipWith (x => y => show x + show y) [1, 2, 3] [True, False, True] // => [\"1True\", \"2False\", \"3True\"]","title":"List Type"},{"location":"sircle_dsl/basics/#tuple-type","text":"","title":"Tuple Type"},{"location":"sircle_dsl/basics/#mapping-type","text":"","title":"Mapping Type"},{"location":"sircle_dsl/basics/#lambda-type","text":"","title":"Lambda Type"},{"location":"sircle_dsl/grammar/","text":"Formal Grammar of Sircle Value Expression 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 value_expr ::= func_app binary_op func_app | unary_op func_app func_app = value_term func_app | value_term value_term ::= lexeme | symbol_name | [ value_expr ( ',' value_expr )* ] | '{' ( string_lexeme '->' value_expr )+ '}' | '{' [ effect ( ';' effect )* ] '}' | '(' value_expr ( ',' value_expr )* ')' | '(' value_expr ')' | if_expr | for_expr effect ::= 'def' symbol_name [ ':' type_expr ] '=' value_expr | symbol_name '=' value_expr | value_expr if_expr ::= 'if' value_expr 'then' value_expr [ 'else' value_expr ] for_expr ::= 'for' for_comb ( ',' for_comb )* 'do' value_expr for_comb ::= symbol_name '<-' value_expr | value_expr Type Expression 1 2 3 4 5 6 type_expr ::= type_term ( '->' type_term )* type_term ::= primitive_type | symbol_name | '(' type_expr ')' | '(' type_expr ( ',' type_expr )* ')' | '{' [ string_lexeme ':' type_expr ( string_lexeme ':' type_expr )* ] '}' Top-level Value Binding 1 top_value_binding ::= 'def' symbol_name [ ':' type_expr ] '=' value_expr Top-level Type Binding 1 top_type_binding ::= 'type' symbol_name '=' type_expr","title":"Formal Grammar"},{"location":"sircle_dsl/grammar/#formal-grammar-of-sircle","text":"","title":"Formal Grammar of Sircle"},{"location":"sircle_dsl/grammar/#value-expression","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 value_expr ::= func_app binary_op func_app | unary_op func_app func_app = value_term func_app | value_term value_term ::= lexeme | symbol_name | [ value_expr ( ',' value_expr )* ] | '{' ( string_lexeme '->' value_expr )+ '}' | '{' [ effect ( ';' effect )* ] '}' | '(' value_expr ( ',' value_expr )* ')' | '(' value_expr ')' | if_expr | for_expr effect ::= 'def' symbol_name [ ':' type_expr ] '=' value_expr | symbol_name '=' value_expr | value_expr if_expr ::= 'if' value_expr 'then' value_expr [ 'else' value_expr ] for_expr ::= 'for' for_comb ( ',' for_comb )* 'do' value_expr for_comb ::= symbol_name '<-' value_expr | value_expr","title":"Value Expression"},{"location":"sircle_dsl/grammar/#type-expression","text":"1 2 3 4 5 6 type_expr ::= type_term ( '->' type_term )* type_term ::= primitive_type | symbol_name | '(' type_expr ')' | '(' type_expr ( ',' type_expr )* ')' | '{' [ string_lexeme ':' type_expr ( string_lexeme ':' type_expr )* ] '}'","title":"Type Expression"},{"location":"sircle_dsl/grammar/#top-level-value-binding","text":"1 top_value_binding ::= 'def' symbol_name [ ':' type_expr ] '=' value_expr","title":"Top-level Value Binding"},{"location":"sircle_dsl/grammar/#top-level-type-binding","text":"1 top_type_binding ::= 'type' symbol_name '=' type_expr","title":"Top-level Type Binding"},{"location":"sircle_dsl/introduction/","text":"Introduction to Sircle What is Sircle? Sircle is a powerful DSL for defining tasks. It is in functional style, supporting first-class functions and currying. Example 1 mkTask \"main.py\" { \"seed\" -> 123, \"base_model\" -> \"GCN\" } { \"base_model\" -> \"GCN\" } This will create a task with executable main.py and arguments. It may be executed by the runner with something like 1 python main.py --seed 123 --base_model GCN # ... and some other flags The last argument, { \"base_model\" -> \"GCN\" } here, is the tag. It is used to identify the task, and is needed to aggregate and display task results. The above Task datatype consists of three elements, Executable, which is the actual computational task. In most cases it is a Python script. Arguments, which specify the argument passed to the executable. Tag, which identifies the task and helps experiment results handling. Apart from the above constructor, we can also construct a Task with two operators: task1 >> task2 , which defines a task where tasks1 is executed first, then task2 . task1 || task2 , which defines a task where task1 and task2 can be executed in paralell. Sircle DSL is highly expressive for defining computational tasks. For a real-world example, considering the conifig 1 2 3 4 5 def config = { \"seed\" -> [1, 2, 3], \"dataset\" -> [\"cora\", \"citeseer\", \"pubmed\"], \"model\" -> [\"GCN\", \"GAT\"] } and we want to run experiments with combination of different argments. We would like to run experiments with different seeds in parallel, and for any specific seeds, we run the experiments sequentially. To express the above task structures, we can write Sircle code like 1 2 3 4 5 def resolve = config => mkPar { def c = restrict [\"dataset\", \"model\"] config; for seed <- config.\"seed\" do mkSeq $ map (x => mkTask \"main.py\" x $ x + { \"seed\" -> seed }) $ namedProd c } On the other hand, from the short example above, we can see some basic properties of Sircle. A first glance at Sircle Function application The function application in Sircle follows the ML style, where brackets are omitted. In other words, instead of writing 1 f(x, y) we write 1 f x y in Sircle. On of the greatest benefits of such style is that it can integrate well with currying. For example, we can write 1 2 def add = x => y => x + y map (add 1) [1, 2, 3] in Sircle, which will produce [2, 3, 4] . Name Binding In sircle, we can use the def keyword to bind a name. For example, 1 def x = 1 And type annotation is also possible, we can write 1 def x: Int = 1 The evaluator will check the value type of the right hand and verify that it is consistent with the type annotation. In other words, the following binding 1 def x: Int = \"1\" will result in a runtime error. Actually, when we omit the type annotation in the binding, the type is assumed Any , which will be consistent with any value types. In Sircle source, name bindings can happen both at global level and in block expressions. For instance, 1 2 3 4 5 6 7 def x = 1 def main = unused: Unit => { def y = x + 1; y = 2 * y; y } A block expression contains a sequence of effective statements separated by commas, enclosed in curly braces. There are three types of effects: Binding. Example: def y = x + 1 . This will bind value x + 1 to name y and evaluate to the binded value. Reassignment. Example: y = 2 * y . This will assign a new value 2 * y to the name y and evaluate to the new value. Eval. Example: y . This is simply a pure expression and will evaluate to a value. The block expression will evaluate the effects one by one, with possibly modification to variable environments, and return the value of the last effect. This style is similar to Scala. The global bindings, unlike bindings in the block expressions, are immutable. The Mapping Datatype The expression 1 2 3 4 5 { \"seed\" -> [1, 2, 3], \"dataset\" -> [\"cora\", \"citeseer\", \"pubmed\"], \"model\" -> [\"GCN\", \"GAT\"] } will result in a Mapping value, which is similar to dict in Python and something called map in other languages. It is a key-value mapping, with keys must being String types. Mapping s are used in Sircle to describe task arguments and tags. It is possible to access the Mapping values by 1 2 config.\"seed\" // => [1, 2, 3] and update it with 1 2 config + { \"seed\" -> [3, 2, 1] } // => { \"seed\" -> [3, 2, 1], ... } More details on datatypes will be discussed later. Lambdas The expression 1 x => x + 1 will evaluate to a lambda function. Function definition in Sircle, for instance, 1 def add = x: Int => y: Int => x + y is simply binding a lambda to a name. Note that we can use annotations to specify the argument type. The above definition is mostly equivalent to the code in other programming languages: Example Python 1 2 def add ( x : int , y : int ): return x + y Scala 1 val add = ( x : Int , y : Int ) => x + y Haskell 1 2 add :: Int -> Int -> Int add x y = x + y Generally, we can define a \\(n\\) -arg function with 1 def funcName = arg1: Type1 => arg2: Type2 => ... => argN: typeN => bodyExpr","title":"Introduction to Sircle"},{"location":"sircle_dsl/introduction/#introduction-to-sircle","text":"","title":"Introduction to Sircle"},{"location":"sircle_dsl/introduction/#what-is-sircle","text":"Sircle is a powerful DSL for defining tasks. It is in functional style, supporting first-class functions and currying. Example 1 mkTask \"main.py\" { \"seed\" -> 123, \"base_model\" -> \"GCN\" } { \"base_model\" -> \"GCN\" } This will create a task with executable main.py and arguments. It may be executed by the runner with something like 1 python main.py --seed 123 --base_model GCN # ... and some other flags The last argument, { \"base_model\" -> \"GCN\" } here, is the tag. It is used to identify the task, and is needed to aggregate and display task results. The above Task datatype consists of three elements, Executable, which is the actual computational task. In most cases it is a Python script. Arguments, which specify the argument passed to the executable. Tag, which identifies the task and helps experiment results handling. Apart from the above constructor, we can also construct a Task with two operators: task1 >> task2 , which defines a task where tasks1 is executed first, then task2 . task1 || task2 , which defines a task where task1 and task2 can be executed in paralell. Sircle DSL is highly expressive for defining computational tasks. For a real-world example, considering the conifig 1 2 3 4 5 def config = { \"seed\" -> [1, 2, 3], \"dataset\" -> [\"cora\", \"citeseer\", \"pubmed\"], \"model\" -> [\"GCN\", \"GAT\"] } and we want to run experiments with combination of different argments. We would like to run experiments with different seeds in parallel, and for any specific seeds, we run the experiments sequentially. To express the above task structures, we can write Sircle code like 1 2 3 4 5 def resolve = config => mkPar { def c = restrict [\"dataset\", \"model\"] config; for seed <- config.\"seed\" do mkSeq $ map (x => mkTask \"main.py\" x $ x + { \"seed\" -> seed }) $ namedProd c } On the other hand, from the short example above, we can see some basic properties of Sircle.","title":"What is Sircle?"},{"location":"sircle_dsl/introduction/#a-first-glance-at-sircle","text":"","title":"A first glance at Sircle"},{"location":"sircle_dsl/introduction/#function-application","text":"The function application in Sircle follows the ML style, where brackets are omitted. In other words, instead of writing 1 f(x, y) we write 1 f x y in Sircle. On of the greatest benefits of such style is that it can integrate well with currying. For example, we can write 1 2 def add = x => y => x + y map (add 1) [1, 2, 3] in Sircle, which will produce [2, 3, 4] .","title":"Function application"},{"location":"sircle_dsl/introduction/#name-binding","text":"In sircle, we can use the def keyword to bind a name. For example, 1 def x = 1 And type annotation is also possible, we can write 1 def x: Int = 1 The evaluator will check the value type of the right hand and verify that it is consistent with the type annotation. In other words, the following binding 1 def x: Int = \"1\" will result in a runtime error. Actually, when we omit the type annotation in the binding, the type is assumed Any , which will be consistent with any value types. In Sircle source, name bindings can happen both at global level and in block expressions. For instance, 1 2 3 4 5 6 7 def x = 1 def main = unused: Unit => { def y = x + 1; y = 2 * y; y } A block expression contains a sequence of effective statements separated by commas, enclosed in curly braces. There are three types of effects: Binding. Example: def y = x + 1 . This will bind value x + 1 to name y and evaluate to the binded value. Reassignment. Example: y = 2 * y . This will assign a new value 2 * y to the name y and evaluate to the new value. Eval. Example: y . This is simply a pure expression and will evaluate to a value. The block expression will evaluate the effects one by one, with possibly modification to variable environments, and return the value of the last effect. This style is similar to Scala. The global bindings, unlike bindings in the block expressions, are immutable.","title":"Name Binding"},{"location":"sircle_dsl/introduction/#the-mapping-datatype","text":"The expression 1 2 3 4 5 { \"seed\" -> [1, 2, 3], \"dataset\" -> [\"cora\", \"citeseer\", \"pubmed\"], \"model\" -> [\"GCN\", \"GAT\"] } will result in a Mapping value, which is similar to dict in Python and something called map in other languages. It is a key-value mapping, with keys must being String types. Mapping s are used in Sircle to describe task arguments and tags. It is possible to access the Mapping values by 1 2 config.\"seed\" // => [1, 2, 3] and update it with 1 2 config + { \"seed\" -> [3, 2, 1] } // => { \"seed\" -> [3, 2, 1], ... } More details on datatypes will be discussed later.","title":"The Mapping Datatype"},{"location":"sircle_dsl/introduction/#lambdas","text":"The expression 1 x => x + 1 will evaluate to a lambda function. Function definition in Sircle, for instance, 1 def add = x: Int => y: Int => x + y is simply binding a lambda to a name. Note that we can use annotations to specify the argument type. The above definition is mostly equivalent to the code in other programming languages: Example Python 1 2 def add ( x : int , y : int ): return x + y Scala 1 val add = ( x : Int , y : Int ) => x + y Haskell 1 2 add :: Int -> Int -> Int add x y = x + y Generally, we can define a \\(n\\) -arg function with 1 def funcName = arg1: Type1 => arg2: Type2 => ... => argN: typeN => bodyExpr","title":"Lambdas"},{"location":"sircle_dsl/prelude/","text":"Prelude There are a Prelude source preloaded into the Sircle runtime whenever Sircle is launched. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def map = f: Any -> Any => xs: List => for x <- xs do f x def valuesOf = map: { } => for k <- keysOf map do map.k def itemsOf = map: { } => for k <- keysOf map do (k, map.k) def foldl = op: Any -> Any => z: Any => xs: List => { def ret = z; for x <- xs do { ret = op ret x }; ret } def foldl1 = op: Any -> Any => xs: List => foldl op (head xs) (tail xs) def prod = xs: List => foldl1 (x: List => y: List => x * y) xs def min = x => y => if x > y then y else x def max = x => y => if x > y then x else y def zipWith = op: Any -> Any -> Any => xs: List => ys: List => { def len = min (length xs) (length ys); for i <- range len do op (xs.i) (ys.i) } def zip = zipWith $ x => y => (x, y) def restrict = keys: List => map: {} => buildMapping { for key <- keys do (key, map.key) } def namedProd = map: {} => { def keys = keysOf map; def pairs = map toList $ prod $ valuesOf map; def namedPairs = map (zip keys) pairs; map buildMapping namedPairs } def replicate = n: Int => x: Any => for i <- range n do x def cat = foldl1 (x: List => y: List => x + y) def compose = f: Any -> Any => g: Any -> Any => x: Any => f (g x) def flatMap = f: Any -> Any => compose cat $ map f def filter = f: Any -> Any => xs: List => for x <- xs, f x do x def println = x: Any => { print x; print \"\\n\" } def getFibonacci = n: Any => { if (n == 0) then [] else if (n == 1) then [1] else { def ret = [1, 1]; def x = 1; def y = 1; for i <- range (n - 2) do { def t = x + y; ret = ret + [t]; x = y; y = t }; ret } } def mkSeq = xs: List => { def ret = head xs; for t <- tail xs do { ret = ret >> t }; ret } def mkPar = xs: List => { def ret = head xs; for t <- tail xs do { ret = ret || t }; ret } def fiboMain = n: Int => { println \"fibonacci array\"; def arr = getFibonacci n; for i <- range n do { print \"fibo(\"; print i; print \") = \"; println (arr.i) } }","title":"Prelude Functions"},{"location":"sircle_dsl/prelude/#prelude","text":"There are a Prelude source preloaded into the Sircle runtime whenever Sircle is launched. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def map = f: Any -> Any => xs: List => for x <- xs do f x def valuesOf = map: { } => for k <- keysOf map do map.k def itemsOf = map: { } => for k <- keysOf map do (k, map.k) def foldl = op: Any -> Any => z: Any => xs: List => { def ret = z; for x <- xs do { ret = op ret x }; ret } def foldl1 = op: Any -> Any => xs: List => foldl op (head xs) (tail xs) def prod = xs: List => foldl1 (x: List => y: List => x * y) xs def min = x => y => if x > y then y else x def max = x => y => if x > y then x else y def zipWith = op: Any -> Any -> Any => xs: List => ys: List => { def len = min (length xs) (length ys); for i <- range len do op (xs.i) (ys.i) } def zip = zipWith $ x => y => (x, y) def restrict = keys: List => map: {} => buildMapping { for key <- keys do (key, map.key) } def namedProd = map: {} => { def keys = keysOf map; def pairs = map toList $ prod $ valuesOf map; def namedPairs = map (zip keys) pairs; map buildMapping namedPairs } def replicate = n: Int => x: Any => for i <- range n do x def cat = foldl1 (x: List => y: List => x + y) def compose = f: Any -> Any => g: Any -> Any => x: Any => f (g x) def flatMap = f: Any -> Any => compose cat $ map f def filter = f: Any -> Any => xs: List => for x <- xs, f x do x def println = x: Any => { print x; print \"\\n\" } def getFibonacci = n: Any => { if (n == 0) then [] else if (n == 1) then [1] else { def ret = [1, 1]; def x = 1; def y = 1; for i <- range (n - 2) do { def t = x + y; ret = ret + [t]; x = y; y = t }; ret } } def mkSeq = xs: List => { def ret = head xs; for t <- tail xs do { ret = ret >> t }; ret } def mkPar = xs: List => { def ret = head xs; for t <- tail xs do { ret = ret || t }; ret } def fiboMain = n: Int => { println \"fibonacci array\"; def arr = getFibonacci n; for i <- range n do { print \"fibo(\"; print i; print \") = \"; println (arr.i) } }","title":"Prelude"}]}